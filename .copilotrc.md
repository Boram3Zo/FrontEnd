# GitHub Copilot Context

## 프로젝트 개요

- **프로젝트명**: 치카쿠 (Chikaku) - 반려동물 산책 앱
- **기술 스택**: Next.js 15, TypeScript, Tailwind CSS
- **아키텍처**: App Router, 컴포넌트 기반 설계

## 코딩 컨벤션

### 폴더 구조

```
app/
├── _components/     # 재사용 가능한 컴포넌트
├── _hooks/         # 커스텀 훅
├── _libs/          # 라이브러리 및 서비스
├── _types/         # TypeScript 타입 정의
├── _utils/         # 유틸리티 함수
├── _constants/     # 상수 정의
└── (auth)/         # 라우트 그룹
```

### 네이밍 규칙

- **컴포넌트**: PascalCase (예: `LoginForm`, `CatCharacter`)
- **훅**: camelCase + use 접두사 (예: `useLoginForm`, `useWalkTracker`)
- **유틸함수**: camelCase (예: `validateEmail`, `formatDate`)
- **타입**: PascalCase (예: `LoginFormData`, `WalkingSession`)

### 컴포넌트 패턴

1. **폼 컴포넌트**:

   - 별도 훅으로 로직 분리 (예: `LoginForm` + `useLoginForm`)
   - `FormField` 컴포넌트 사용으로 일관성 유지
   - 에러 처리 및 로딩 상태 관리

2. **페이지 컴포넌트**:
   - 레이아웃은 `Header` + `main` + `BottomNavigation` 구조
   - 비즈니스 로직은 별도 컴포넌트로 분리

### TypeScript 사용법

- 모든 props에 타입 정의
- API 응답에 대한 타입 정의 (`_types/` 폴더)
- 유니온 타입과 옵셔널 프로퍼티 적극 활용

### 테스트 규칙

#### Jest 단위 테스트

- 유닛 테스트: `*.test.ts|tsx` 확장자 사용
- React Testing Library 사용
- 훅 테스트: `@testing-library/react-hooks` 활용
- 모든 서비스 레이어 모킹

#### 필수 테스트 파일 생성 규칙

**IMPORTANT**: 새로운 훅이나 컴포넌트 생성 시 반드시 테스트 파일도 함께 생성해야 합니다.

- **커스텀 훅**: `useExample.ts` → `useExample.test.ts` 함께 생성
- **컴포넌트**: `Example.tsx` → `Example.test.tsx` 함께 생성
- **서비스/유틸**: `service.ts` → `service.test.ts` 함께 생성
- **테스트 파일은 같은 폴더에 위치**하며, 최소한의 기본 테스트 케이스 포함

#### Scripts 폴더 테스트

**Jest 통합 테스트** (권장):

- **파일명**: `scripts/[기능명].test.js` 또는 `scripts/[기능명].test.ts`
- **자동 실행**: `npm test` 실행 시 Jest에 의해 자동으로 포함됨
- **형식**: Jest 테스트 형식 사용 (`describe`, `it`, `expect` 등)
- **용도**: 유틸리티 함수, API 로직, 통합 시나리오 테스트

**IMPORTANT**: scripts 폴더에 테스트를 추가할 때는 `.test.js` 또는 `.test.ts` 확장자를 사용하면 `npm test` 명령어로 자동 실행됩니다.

### UI/UX 가이드라인

- Tailwind CSS 클래스 사용
- 반응형 디자인 (모바일 퍼스트)
- 일관된 컬러 팔레트: orange/pink 그라디언트
- 아이콘: 이모지 사용 (🐾, 📍, 📷 등)

## 자주 사용하는 패턴

### 1. 폼 처리

```typescript
// 훅에서 폼 상태 관리
const [formData, setFormData] = useState<FormType>({});
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState("");

// 유효성 검사 후 API 호출
const handleSubmit = async (e: React.FormEvent) => {
	e.preventDefault();
	const validationError = validateForm(formData);
	if (validationError) {
		setError(validationError);
		return;
	}
	// API 호출 로직
};
```

### 2. API 서비스 패턴

```typescript
export class ApiService {
	static async methodName(data: RequestType): Promise<ResponseType> {
		const response = await fetch(getApiUrl(ENDPOINT), {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(data),
		});

		if (!response.ok) {
			const errorData = await response.json();
			throw new Error(errorData.message || "요청에 실패했습니다.");
		}

		return response.json();
	}
}
```

### 3. 에러 처리

- try-catch로 에러 캐치
- 사용자 친화적 에러 메시지 표시
- 로딩 상태는 항상 finally에서 해제

### 4. Scripts API 테스트 패턴

```javascript
// scripts/test-[기능명].mjs 템플릿
#!/usr/bin/env node

console.log("🧪 [기능명] API 테스트 시작");

async function test기능명() {
    try {
        // 실제 API 호출
        const apiBaseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:9988";
        const response = await fetch(`${apiBaseUrl}/api/endpoint`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(testData)
        });

        const result = await response.json();
        console.log("✅ 성공:", result);
    } catch (error) {
        console.error("❌ 실패:", error.message);
    }
}

test기능명().catch(console.error);
```

**Scripts 테스트 사용 시기:**

- API 개발 완료 후 실제 서버와의 통신 검증
- 백엔드 API 스펙 변경 확인
- 프론트엔드 배포 전 최종 검증
- 개발 중 빠른 디버깅이 필요한 경우

### 5. 테스트 파일 생성 패턴

#### 커스텀 훅 테스트

```typescript
// useExample.test.ts 템플릿
import { renderHook, act } from "@testing-library/react";
import { useExample } from "./useExample";

describe("useExample", () => {
	it("초기 상태가 올바르게 설정된다", () => {
		const { result } = renderHook(() => useExample());

		expect(result.current.value).toBe(initialValue);
		expect(result.current.isLoading).toBe(false);
	});

	it("상태 변경이 올바르게 작동한다", () => {
		const { result } = renderHook(() => useExample());

		act(() => {
			result.current.updateValue("new value");
		});

		expect(result.current.value).toBe("new value");
	});
});
```

#### 컴포넌트 테스트

```tsx
// ExampleComponent.test.tsx 템플릿
import { render, screen, fireEvent } from "@testing-library/react";
import { ExampleComponent } from "./ExampleComponent";

describe("ExampleComponent", () => {
	it("컴포넌트가 올바르게 렌더링된다", () => {
		render(<ExampleComponent />);

		expect(screen.getByText("예상 텍스트")).toBeInTheDocument();
	});

	it("사용자 상호작용이 올바르게 처리된다", () => {
		const mockCallback = jest.fn();
		render(<ExampleComponent onAction={mockCallback} />);

		fireEvent.click(screen.getByRole("button"));
		expect(mockCallback).toHaveBeenCalledTimes(1);
	});
});
```

#### 서비스/유틸 함수 테스트

```typescript
// service.test.ts 템플릿
import { exampleService } from "./service";

// Mock fetch
global.fetch = jest.fn();

describe("exampleService", () => {
	beforeEach(() => {
		(fetch as jest.MockedFunction<typeof fetch>).mockClear();
	});

	it("API 호출이 성공적으로 처리된다", async () => {
		(fetch as jest.MockedFunction<typeof fetch>).mockResolvedValue({
			ok: true,
			json: async () => ({ success: true }),
		} as Response);

		const result = await exampleService.getData();
		expect(result.success).toBe(true);
	});

	it("API 에러가 올바르게 처리된다", async () => {
		(fetch as jest.MockedFunction<typeof fetch>).mockRejectedValue(new Error("Network error"));

		await expect(exampleService.getData()).rejects.toThrow("Network error");
	});
});
```

**테스트 파일 생성 체크리스트:**

- [ ] 새 파일 생성 시 동일 폴더에 `.test` 파일 함께 생성
- [ ] 최소 2개 이상의 테스트 케이스 작성 (성공/실패 시나리오)
- [ ] 적절한 모킹 설정 (API, 외부 의존성)
- [ ] 테스트 실행 후 통과 확인 (`npm test`)

## 문서화 프로세스

### 작업 완료 시 문서 생성 규칙

**모든 작업 완료 시 반드시 문서화를 진행해야 합니다.**

1. **문서 타입 결정**:

   - `change`: 기존 기능 수정/개선
   - `refactoring`: 코드 구조 개선
   - `feature`: 완전히 새로운 기능 추가

2. **자동 문서 생성**:

   ```bash
   # 대화형 모드
   npm run docs:create

   # 직접 생성
   npm run docs:create [타입] [제목] [설명?]
   ```

3. **문서 작성 가이드라인**:
   - 변경 사항을 구체적으로 기술
   - 코드 예시 포함
   - Before/After 비교 제공
   - 테스트 방법 명시
   - 사용법 가이드 작성

### 문서 저장 위치

```
docs/
├── changes/       # 기능 변경/수정
├── refactoring/   # 리팩토링
├── features/      # 새 기능
└── templates/     # 문서 템플릿
```

### GitHub Copilot 자동 문서화 규칙

**IMPORTANT**: GitHub Copilot은 모든 작업 완료 시 자동으로 다음을 수행해야 합니다:

1. **작업 타입 자동 판단**: change/refactoring/feature 중 선택
2. **테스트 파일 자동 생성**: 새 훅/컴포넌트 생성 시 `.test` 파일 함께 생성
3. **자동 문서 생성**: `npm run docs:create [타입] [제목]` 실행
   - 파일명: `YYYY-MM-DD-HHMM-작업내용.md` 형식으로 자동 생성
   - 예: `2025-09-14-1455-회원가입-메인화면-이동.md`
4. **문서 내용 작성**: 템플릿을 활용하여 상세 내용 작성

### 사용자 요청 예시

작업 완료 후 사용자가 다음과 같이 요청할 수 있습니다:

> "이 작업에 대한 문서를 생성해주세요."  
> "작업 완료 문서화 해주세요."  
> "docs 폴더에 문서 만들어줘."

## 주의사항

- localStorage 사용 시 서버사이드 렌더링 고려
- 이미지 업로드 시 압축 및 최적화 필수
- 지도 API 사용 시 환경변수로 키 관리
- 반응형 디자인에서 터치 이벤트 고려
- **작업 완료 시 반드시 문서화 진행**
